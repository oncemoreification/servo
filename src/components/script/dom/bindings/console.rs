

extern fn log(cx: *JSContext, argc: c_uint, vp: *JSVal) -> JSBool {
  unsafe {
    let argv = JS_ARGV(cx, vp);
    assert!(argc == 1);
    // Abstract this pattern and use it in debug, too?
    let jsstr = JS_ValueToString(cx, *ptr::offset(argv, 0));
    if jsstr.is_null() {
        return 0;
    }

    (*unwrap(JS_THIS_OBJECT(cx, vp))).payload.log(jsval_to_rust_str(cx, jsstr));

    JS_SET_RVAL(cx, vp, JSVAL_NULL);
    return 1;
  }
}

pub fn init(compartment: @mut Compartment) {
    let proto = utils::define_empty_prototype(~"Console", None, compartment);
    compartment.register_class(utils::instance_jsclass(~"ConsoleInstance", finalize, null()));

    let methods = [
        JSFunctionSpec {
            name: compartment.add_name(~"log"),
            call: JSNativeWrapper { op: log, info: null() },
            nargs: 1,
            flags: 0,
            selfHostedName: null()
        },
    JS_DefineFunctions(compartment.cx.ptr, proto.ptr, &methods[0]);
}


// TODO(jj): Code like this could definitely be abstracted or autogenerated for bindings
// Issue #484 seems related
pub fn create(compartment: @mut Compartment, console: @mut Console) {
    let obj = result::unwrap(
                 compartment.new_object_with_proto(~"ConsoleInstance",
                                                   ~"Console", null()));

    win.get_wrappercache().set_wrapper(obj.ptr);

    unsafe {
        let raw_ptr: *libc::c_void = cast::transmute(squirrel_away(win));
        JS_SetReservedSlot(obj.ptr, 0, RUST_PRIVATE_TO_JSVAL(raw_ptr));
    }

    compartment.define_property(~"console", RUST_OBJECT_TO_JSVAL(obj.ptr),
                                JS_PropertyStub, JS_StrictPropertyStub,
                                JSPROP_ENUMERATE);
}
